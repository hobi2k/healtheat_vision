Atlas 분석 결과 공유
모델 정의와 학습 루프를 살펴본 결과는 다음과 같습니다.

### 모델 구조 확인

* **`src/detection/model.py`**에서는 COCO 데이터셋으로 사전학습된 Faster R‑CNN (ResNet‑50‑FPN 백본)을 로딩합니다. 그 후 기존 `roi_heads.box_predictor`를 제거하고, 분류기 헤드를 `FastRCNNPredictor(in_features, num_classes)`로 교체합니다. `num_classes`는 배경을 포함한 전체 클래스 수입니다. 이 방식은 사전학습된 모델의 백본과 RPN을 그대로 활용하면서 분류기 헤드만 새로 학습할 수 있도록 설계된 전형적인 방식입니다.
* **학습 루프 (`src/detection/train.py`)**에서는 `PillDataset`에서 얻은 `sorted_cat_ids`의 길이에 1을 더해 클래스 수를 결정합니다. 이렇게 하면 모델이 **0: 배경 + 1..N: 실제 클래스**의 연속된 라벨을 사용합니다. 이 모델은 `get_model(num_classes)`를 호출해 생성되고, SGD 옵티마이저와 50에폭 학습 설정을 사용합니다.

### class_map과 ID 매핑

* **`PillDataset`**은 각 주석 파일을 돌면서 `categories` 혹은 `annotations`에 있는 `id`를 모두 수집해 `all_ids` 집합에 넣고, 이를 정렬해 `sorted_cat_ids`로 저장합니다. 또한 `cat_to_idx` 딕셔너리를 만들어 원본 카테고리 ID를 0부터 시작하는 연속된 인덱스로 변환해 학습 타깃으로 사용합니다.
* 학습 시 타깃 라벨은 이 `cat_to_idx`를 통해 **원본 ID → 연속된 인덱스**로 변환되므로, 모델의 출력 클래스는 `sorted_cat_ids`의 인덱스 순서와 일치합니다.
* 그러나 **`src/detection/inference.py`**의 `get_class_names()`는 `train_annotations.json`의 `categories`를 읽어 `class_map = { cat['id']: cat['name'] }` 형태로 생성하고, 클래스 수를 `len(class_map) + 1`로 계산합니다. 이 방식은 원본 ID를 그대로 키로 사용하기 때문에 훈련에 사용한 인덱스 체계와 불일치할 가능성이 큽니다.
* 마찬가지로 **`submit.py`**에서도 주석 파일을 모두 스캔해 원본 `id` 집합을 정렬하는 `get_all_category_ids()`를 제공하지만, 모델의 예측값을 어떻게 이 ID로 다시 매핑할지에 대한 로직이 없습니다. 따라서 모델이 반환하는 **라벨 인덱스**를 그대로 `class_map`의 키로 해석하면, 실제 정답과 다른 ID를 출력하게 됩니다.

### 원인과 해결 제안

* 문제의 핵심은 **학습과 추론에서 사용되는 클래스 매핑 기준이 다르다는 것**입니다. 학습에서는 `sorted_cat_ids`/`cat_to_idx`를 사용해 라벨을 0‑베이스로 재매핑했지만, 추론에서는 데이터셋의 원본 ID를 기반으로 클래스 수를 계산하고 그 ID를 이름과 연결했습니다. 이 때문에 모델이 출력한 라벨 인덱스가 잘못된 원본 ID에 대응되어 “정답이 아닌 id값”을 뽑는 현상이 발생할 수 있습니다.
* 해결책으로는 다음을 고려할 수 있습니다.

  1. **단일 매핑 사용**: 학습 단계에서 생성한 `sorted_cat_ids`를 파일로 저장한 후, 추론/제출 시 이 리스트를 읽어 `(모델 출력 라벨 인덱스 → 원본 category_id)`로 다시 변환합니다. 예를 들어 `pred_label`이 3이면 `true_id = sorted_cat_ids[3]`로 변환한 뒤 이를 `class_map[true_id]`에 연결하면 됩니다.
  2. **연속된 ID 사용**: 만약 원본 데이터셋의 카테고리 ID가 이미 1부터 N까지 연속적이라면, `PillDataset`에서 ID를 재매핑하지 않고 그대로 사용하고 `num_classes = max_id + 1`로 설정하면 학습과 추론의 기준이 일치합니다. 다만 불연속한 ID가 있다면 클래스 수가 불필요하게 커질 수 있습니다.
  3. **코드 정비**: `inference.py`와 `submit.py`에서 class_map을 구성할 때 `PillDataset.sorted_cat_ids`나 훈련 시 저장한 매핑 파일을 읽어 올 수 있도록 수정하여, 학습과 동일한 매핑을 사용하도록 합니다.

위 코드 스니펫을 보면 `submit.py`의 상단에서 모델과 데이터를 로딩하기 위한 상수 정의와 일부 보조 함수가 정의되어 있으며(`extract_number`, `get_all_category_ids` 등), 제출 파일을 작성하는 메인 루프가 이어집니다. 이 스크립트에서도 클래스 ID 재매핑 로직이 없어 추론 결과를 잘못된 ID로 작성할 여지가 있습니다.

따라서 ID가 잘못 매핑되는 문제를 해결하려면 학습에 사용한 `sorted_cat_ids`/`cat_to_idx`를 추론과 제출 단계에서도 그대로 활용하도록 코드를 수정하는 것이 중요합니다.
